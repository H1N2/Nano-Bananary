# Nano Bananary 系统架构说明

## 1. 架构概览

### 1.1 架构类型
Nano Bananary 采用**前端单页应用（SPA）架构**，基于 React 框架构建，通过调用 Google Gemini AI API 实现图像处理功能。

### 1.2 架构特点
- **轻量级**：纯前端应用，无需后端服务器
- **响应式**：基于组件化设计，支持实时交互
- **可扩展**：模块化架构，便于功能扩展
- **高性能**：客户端处理，减少网络延迟

## 2. 系统分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                     表现层 (Presentation Layer)              │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │   UI Components │ │  Layout Manager │ │  Event Handlers │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     应用层 (Application Layer)               │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │  State Manager  │ │ Business Logic  │ │  Flow Control   │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     服务层 (Service Layer)                   │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │   AI Service    │ │   File Service  │ │  Utility Service│ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     数据层 (Data Layer)                      │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │  Local Storage  │ │   Memory Cache  │ │   File System   │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                     基础设施层 (Infrastructure Layer)         │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │   Browser APIs  │ │   External APIs │ │   Build Tools   │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.1 表现层 (Presentation Layer)
负责用户界面展示和用户交互处理。

**核心组件：**
- **UI Components**: 可复用的界面组件
- **Layout Manager**: 布局管理和响应式设计
- **Event Handlers**: 用户事件处理和响应

**主要职责：**
- 渲染用户界面
- 处理用户输入
- 展示应用状态
- 提供交互反馈

### 2.2 应用层 (Application Layer)
负责业务逻辑处理和应用状态管理。

**核心模块：**
- **State Manager**: 应用状态管理
- **Business Logic**: 业务规则和流程
- **Flow Control**: 用户操作流程控制

**主要职责：**
- 管理应用状态
- 协调组件交互
- 实现业务逻辑
- 控制数据流向

### 2.3 服务层 (Service Layer)
提供具体的功能服务和外部接口封装。

**核心服务：**
- **AI Service**: Google Gemini API 集成
- **File Service**: 文件处理和管理
- **Utility Service**: 通用工具服务

**主要职责：**
- 封装外部API调用
- 提供文件处理功能
- 实现通用工具方法
- 处理错误和异常

### 2.4 数据层 (Data Layer)
负责数据存储和缓存管理。

**存储方案：**
- **Local Storage**: 持久化用户配置
- **Memory Cache**: 临时数据缓存
- **File System**: 文件临时存储

**主要职责：**
- 数据持久化存储
- 缓存管理优化
- 数据访问接口
- 数据一致性保证

### 2.5 基础设施层 (Infrastructure Layer)
提供底层技术支持和外部依赖。

**基础设施：**
- **Browser APIs**: 浏览器原生API
- **External APIs**: 第三方服务API
- **Build Tools**: 构建和开发工具

## 3. 组件架构设计

### 3.1 组件层次结构

```
App (根组件)
├── TransformationSelector (变换选择器)
│   ├── TransformationCard (变换卡片)
│   └── CustomPromptInput (自定义提示词输入)
├── ImageUploader (图像上传器)
│   ├── DropZone (拖拽区域)
│   └── FileInput (文件输入)
├── MultiImageUploader (多图上传器)
│   ├── PrimaryUploader (主图上传)
│   └── SecondaryUploader (辅图上传)
├── ImageEditorCanvas (图像编辑画布)
│   ├── CanvasRenderer (画布渲染器)
│   ├── MaskEditor (蒙版编辑器)
│   └── ToolSelector (工具选择器)
├── ResultDisplay (结果展示)
│   ├── ImagePreview (图像预览)
│   ├── DownloadButton (下载按钮)
│   └── ShareButton (分享按钮)
├── HistoryPanel (历史面板)
│   ├── HistoryList (历史列表)
│   └── HistoryItem (历史项)
├── LoadingSpinner (加载指示器)
├── ErrorMessage (错误消息)
└── ImagePreviewModal (图像预览模态框)
```

### 3.2 组件通信模式

#### 3.2.1 父子组件通信
```typescript
// 父组件向子组件传递数据
<ChildComponent 
  data={parentData} 
  onEvent={handleChildEvent} 
/>

// 子组件向父组件传递事件
interface ChildProps {
  onEvent: (data: any) => void;
}
```

#### 3.2.2 状态提升模式
```typescript
// 将共享状态提升到最近的共同父组件
const App = () => {
  const [sharedState, setSharedState] = useState();
  
  return (
    <>
      <ComponentA state={sharedState} onUpdate={setSharedState} />
      <ComponentB state={sharedState} onUpdate={setSharedState} />
    </>
  );
};
```

#### 3.2.3 Context 模式（未来扩展）
```typescript
// 用于深层组件通信的Context模式
const AppContext = createContext();

const AppProvider = ({ children }) => {
  const [globalState, setGlobalState] = useState();
  return (
    <AppContext.Provider value={{ globalState, setGlobalState }}>
      {children}
    </AppContext.Provider>
  );
};
```

## 4. 数据流架构

### 4.1 单向数据流

```
用户操作 → 事件处理 → 状态更新 → 组件重渲染 → UI更新
    ↑                                              ↓
    └──────────── 用户反馈 ←─────────────────────────┘
```

### 4.2 数据流详细过程

1. **用户交互触发**
   - 用户点击、上传、绘制等操作
   - 触发相应的事件处理函数

2. **事件处理**
   - 验证用户输入
   - 调用相应的业务逻辑
   - 更新应用状态

3. **状态更新**
   - 使用 React Hooks 更新状态
   - 触发组件重新渲染
   - 更新本地存储（如需要）

4. **UI 重渲染**
   - React 根据状态变化重新渲染组件
   - 更新用户界面显示
   - 提供用户反馈

### 4.3 异步数据流

```
用户操作 → 显示加载状态 → 异步API调用 → 处理响应 → 更新状态 → 隐藏加载状态
                                    ↓
                              错误处理 → 显示错误信息
```

## 5. 服务架构设计

### 5.1 AI 服务架构

```
┌─────────────────────────────────────────────────────────────┐
│                      AI Service Layer                      │
├─────────────────────────────────────────────────────────────┤
│  GeminiService                                              │
│  ├── editImage() - 核心图像处理方法                          │
│  ├── validateInput() - 输入验证                             │
│  ├── buildRequest() - 构建API请求                           │
│  ├── handleResponse() - 处理API响应                         │
│  └── handleError() - 错误处理和重试                         │
├─────────────────────────────────────────────────────────────┤
│                    Request/Response Flow                    │
│                                                             │
│  Client Request → Input Validation → API Call → Response   │
│       ↑                                            ↓        │
│   Error Handling ←─── Error Detection ←─── Response Parse  │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 文件服务架构

```
┌─────────────────────────────────────────────────────────────┐
│                     File Service Layer                     │
├─────────────────────────────────────────────────────────────┤
│  FileUtils                                                  │
│  ├── dataUrlToFile() - 数据格式转换                         │
│  ├── loadImage() - 图像加载                                 │
│  ├── resizeImageToMatch() - 图像尺寸调整                    │
│  ├── embedWatermark() - 水印处理                            │
│  └── downloadImage() - 文件下载                             │
├─────────────────────────────────────────────────────────────┤
│                      Processing Flow                        │
│                                                             │
│  File Input → Validation → Processing → Output → Download  │
│      ↑                                            ↓         │
│  Error Handling ←─── Quality Check ←─── Format Convert     │
└─────────────────────────────────────────────────────────────┘
```

## 6. 状态管理架构

### 6.1 状态分类

```
应用状态 (App State)
├── UI状态 (UI State)
│   ├── 加载状态 (Loading State)
│   ├── 错误状态 (Error State)
│   ├── 模态框状态 (Modal State)
│   └── 工具状态 (Tool State)
├── 业务状态 (Business State)
│   ├── 变换配置 (Transformation Config)
│   ├── 图像数据 (Image Data)
│   ├── 处理结果 (Processing Result)
│   └── 历史记录 (History Data)
└── 持久化状态 (Persistent State)
    ├── 用户偏好 (User Preferences)
    ├── 变换排序 (Transformation Order)
    └── 缓存数据 (Cache Data)
```

### 6.2 状态管理策略

#### 6.2.1 本地状态管理
```typescript
// 使用 useState 管理组件本地状态
const [localState, setLocalState] = useState(initialValue);

// 使用 useReducer 管理复杂状态
const [state, dispatch] = useReducer(reducer, initialState);
```

#### 6.2.2 状态持久化
```typescript
// LocalStorage 持久化
const saveToStorage = (key: string, value: any) => {
  localStorage.setItem(key, JSON.stringify(value));
};

const loadFromStorage = (key: string) => {
  const stored = localStorage.getItem(key);
  return stored ? JSON.parse(stored) : null;
};
```

#### 6.2.3 状态同步
```typescript
// 使用 useEffect 同步状态
useEffect(() => {
  // 状态变化时的副作用处理
  saveToStorage('appState', currentState);
}, [currentState]);
```

## 7. 安全架构设计

### 7.1 客户端安全

```
┌─────────────────────────────────────────────────────────────┐
│                    Client Security Layer                   │
├─────────────────────────────────────────────────────────────┤
│  Input Validation                                           │
│  ├── 文件类型验证                                            │
│  ├── 文件大小限制                                            │
│  ├── 内容安全检查                                            │
│  └── XSS 防护                                               │
├─────────────────────────────────────────────────────────────┤
│  Data Protection                                            │
│  ├── 本地数据加密                                            │
│  ├── 敏感信息过滤                                            │
│  ├── 临时数据清理                                            │
│  └── 隐私保护措施                                            │
├─────────────────────────────────────────────────────────────┤
│  API Security                                               │
│  ├── API 密钥保护                                           │
│  ├── 请求签名验证                                            │
│  ├── 频率限制控制                                            │
│  └── 错误信息过滤                                            │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 数据安全流程

1. **输入验证**
   - 文件格式检查
   - 大小限制验证
   - 恶意内容检测

2. **处理安全**
   - 沙箱环境处理
   - 资源使用限制
   - 超时保护机制

3. **输出安全**
   - 结果内容过滤
   - 水印保护机制
   - 下载安全检查

## 8. 性能架构优化

### 8.1 渲染性能优化

```
┌─────────────────────────────────────────────────────────────┐
│                  Rendering Optimization                    │
├─────────────────────────────────────────────────────────────┤
│  Component Level                                            │
│  ├── React.memo() - 组件记忆化                              │
│  ├── useMemo() - 值记忆化                                   │
│  ├── useCallback() - 函数记忆化                             │
│  └── 懒加载组件                                              │
├─────────────────────────────────────────────────────────────┤
│  Virtual DOM Optimization                                   │
│  ├── Key 优化                                               │
│  ├── 条件渲染优化                                            │
│  ├── 列表渲染优化                                            │
 │  └── 状态更新优化                                            │
├─────────────────────────────────────────────────────────────┤
│  Bundle Optimization                                        │
│  ├── 代码分割                                                │
│  ├── 树摇优化                                                │
│  ├── 压缩优化                                                │
│  └── 缓存策略                                                │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 网络性能优化

```
┌─────────────────────────────────────────────────────────────┐
│                   Network Optimization                     │
├─────────────────────────────────────────────────────────────┤
│  Request Optimization                                       │
│  ├── 请求合并                                                │
│  ├── 并发控制                                                │
│  ├── 重试机制                                                │
│  └── 超时处理                                                │
├─────────────────────────────────────────────────────────────┤
│  Data Optimization                                          │
│  ├── 图像压缩                                                │
│  ├── 格式优化                                                │
│  ├── 增量更新                                                │
│  └── 缓存策略                                                │
├─────────────────────────────────────────────────────────────┤
│  Loading Optimization                                       │
│  ├── 预加载策略                                              │
│  ├── 懒加载实现                                              │
│  ├── 进度反馈                                                │
│  └── 离线支持                                                │
└─────────────────────────────────────────────────────────────┘
```

## 9. 扩展性架构设计

### 9.1 水平扩展能力

```
当前架构 → 插件系统 → 微服务架构 → 分布式系统
    ↓           ↓           ↓           ↓
单体应用    模块化应用    服务化应用    云原生应用
```

### 9.2 功能扩展点

1. **变换插件系统**
   - 自定义变换插件接口
   - 插件注册和管理机制
   - 插件沙箱运行环境

2. **AI 服务扩展**
   - 多AI服务提供商支持
   - 服务切换和负载均衡
   - 自定义AI模型集成

3. **存储扩展**
   - 云存储服务集成
   - 数据库支持
   - 分布式缓存

4. **用户系统扩展**
   - 用户认证和授权
   - 个人工作空间
   - 协作功能支持

### 9.3 技术栈演进路径

```
阶段1: 纯前端SPA
├── React + TypeScript
├── Vite 构建工具
└── 第三方API集成

阶段2: 前后端分离
├── 前端: React SPA
├── 后端: Node.js/Python API
└── 数据库: MongoDB/PostgreSQL

阶段3: 微服务架构
├── 前端: React + 状态管理库
├── API网关: Kong/Nginx
├── 微服务: Docker + Kubernetes
└── 消息队列: Redis/RabbitMQ

阶段4: 云原生架构
├── 前端: PWA + CDN
├── 后端: Serverless Functions
├── 存储: 对象存储 + 数据库
└── AI服务: 云AI平台
```

## 10. 部署架构

### 10.1 开发环境架构

```
┌─────────────────────────────────────────────────────────────┐
│                   Development Environment                   │
├─────────────────────────────────────────────────────────────┤
│  Local Development                                          │
│  ├── Vite Dev Server (热重载)                               │
│  ├── TypeScript 编译器                                      │
│  ├── ESLint + Prettier                                     │
│  └── 本地API代理                                            │
├─────────────────────────────────────────────────────────────┤
│  Build Process                                              │
│  ├── TypeScript 编译                                        │
│  ├── 代码压缩优化                                            │
│  ├── 资源打包                                                │
│  └── 静态资源生成                                            │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 生产环境架构

```
┌─────────────────────────────────────────────────────────────┐
│                   Production Environment                    │
├─────────────────────────────────────────────────────────────┤
│  CDN Layer                                                  │
│  ├── 静态资源分发                                            │
│  ├── 全球加速                                                │
│  ├── 缓存策略                                                │
│  └── HTTPS 支持                                             │
├─────────────────────────────────────────────────────────────┤
│  Web Server                                                 │
│  ├── Nginx/Apache                                          │
│  ├── 负载均衡                                                │
│  ├── SSL 终止                                               │
│  └── 安全防护                                                │
├─────────────────────────────────────────────────────────────┤
│  Monitoring & Logging                                       │
│  ├── 性能监控                                                │
│  ├── 错误追踪                                                │
│  ├── 用户行为分析                                            │
│  └── 日志聚合                                                │
└─────────────────────────────────────────────────────────────┘
```

## 11. 监控和运维架构

### 11.1 监控体系

```
┌─────────────────────────────────────────────────────────────┐
│                    Monitoring System                       │
├─────────────────────────────────────────────────────────────┤
│  Application Monitoring                                     │
│  ├── 性能指标监控                                            │
│  ├── 错误率监控                                              │
│  ├── 用户体验监控                                            │
│  └── API调用监控                                             │
├─────────────────────────────────────────────────────────────┤
│  Infrastructure Monitoring                                  │
│  ├── 服务器资源监控                                          │
│  ├── 网络性能监控                                            │
│  ├── 存储使用监控                                            │
│  └── 安全事件监控                                            │
├─────────────────────────────────────────────────────────────┤
│  Business Monitoring                                        │
│  ├── 用户行为分析                                            │
│  ├── 功能使用统计                                            │
│  ├── 转化率分析                                              │
│  └── 收入指标监控                                            │
└─────────────────────────────────────────────────────────────┘
```

### 11.2 运维流程

1. **持续集成/持续部署 (CI/CD)**
   - 代码提交触发构建
   - 自动化测试执行
   - 部署到测试环境
   - 生产环境发布

2. **版本管理**
   - 语义化版本控制
   - 发布分支管理
   - 回滚机制
   - 灰度发布

3. **故障处理**
   - 监控告警
   - 故障定位
   - 快速修复
   - 事后分析

## 12. 总结

Nano Bananary 的系统架构设计遵循以下核心原则：

1. **简洁性**：采用简单直接的架构模式，降低复杂度
2. **可扩展性**：模块化设计，支持功能和技术栈的演进
3. **高性能**：多层次的性能优化策略
4. **安全性**：全方位的安全防护措施
5. **可维护性**：清晰的代码结构和完善的文档

该架构既满足当前的功能需求，又为未来的扩展和演进提供了良好的基础。通过合理的分层设计和模块化架构，确保系统的稳定性、可维护性和可扩展性。